# Optimanage
Optimanage is an interface to manage optimization loops. Very early stages.
(Oct 2018)

## Motivation
MP is constantly running computationally expensive workflows on supercomputing clusters (Elastic tensor calculations, band structure estimations, structure optimization etc.). Often, these workflows are run in search of materials that satisfy certain properties (e.g. negative poisson ratio, a particular band gap, high ductility etc). Thus, there are several optimization goals that are trying to share computing resources. The purpose of Optimanage is to prioritize the workflows generated by these separate optimization goals to make optimal use of computing resources.


There also exists a way for users to "vote" for new elastic tensor calculations using propjockey (github.com/materialsproject/propjockey).
The framework here could be used to allow users to similarly vote for objectives instead of specific workflows.


## Classes
Objectives represent an optimization goal. (e.g. Maximize ductility).
  Generally, this goal is expected to be a max, min, or target function of one response variable.
  Objectives have associated workflows. Objectives will be able to use model(s) to predict a "score" for an input material.

Workflows are computationally expensive workflows that generally result in further information about a material. This could be a band structure computation, a elastic tensor calculation, a structure optimization etc.

Models are used to predict responses for an input material. These are expected to be ML models that need training data.

Dispatchers manage several objectives that interact with the same dataset. The dataset will likely be in the form of a database that the dispatcher can query. The dispatcher should be able to check for updates in the database and also write to the database. The dispatcher will ask for scores for workflows from its objectives, and weight these scores as a function of the objective that generated them.


## Examples
Say we have created the following classes `HighDuctilityObjective` and `NegativePoissonObjective` which extend `Objective`.
Additionally, for some reason we really want to find a material that is highly ductile so we place greater weight for this objective when adding it to the dispatcher.

```
high_duc_obj = new HighDuctilityObjective()
negative_poisson_obj = new NegativePoissonObjective()
dispatcher = new MPDispatcher(dataset = MPdatabase)
dispatcher.add(objective=high_duc_obj, weight=2)
dispatcher.add(objective=negative_poisson_obj, weight=1)
dispatcher.update()
wflows = dispatcher.rank_wflows(n=10)
```

Then, `wflows` will be a list of 10 workflows that should be run prioritized in the order they are in the list.
